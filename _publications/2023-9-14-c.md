---
title: "C语言八股文大全"
collection: C/C++
permalink: /publication/2023-9-14-c
excerpt: 
date: 2023-9-14
venue: '九月十四号'
paperurl: 
citation: 
---

---
---
---





# **1**.输入字符函数的区别（部分，可补充）

​	`getchar()`, `scanf()`, `getc()`, `gets()`是C语言中用于输入字符的函数，它们之间有一些区别。

1. `getchar()`函数：
   - `getchar()`函数从标准输入流（通常是键盘）中读取一个字符，并返回该字符的ASCII码。
   - 它可以接受任何字符（包括回车、空格等）作为输入。
   - `getchar()`函数需要用户按下回车键才能接受输入。

2. `scanf()`函数：
   - `scanf()`函数是一个格式化输入函数，可以读取不同类型的数据（如整数、浮点数、字符串等）。
   - 它可以接受任何字符作为输入，但根据格式化字符串中的格式进行解析。
   - `scanf()`函数可以使用格式化字符串指定期望的输入格式，并将输入数据存储到对应的变量中。

3. `getc()`函数：
   - `getc()`函数从指定的输入流中读取一个字符，并返回该字符的ASCII码。
   - 它可以接受任何字符（包括回车、空格等）作为输入。
   - `getc()`函数可以读取来自不同输入流（如标准输入流、文件等）的字符。

4. `gets()`函数：
   - `gets()`函数从标准输入流中读取一行字符串，并将其存储在指定的缓冲区中。
   - 它可以接受任何字符（包括回车、空格等）作为输入。
   - `gets()`函数会将读取的字符存储在指定的缓冲区中，直到遇到换行符或文件结束符为止。

​			需要注意的是，`gets()`函数在处理输入时存在安全性问题，因为它无法限制输入字符串的长度，可能导致缓冲区溢出。建议使用更安全的函数，如`fgets()`来替代`gets()`函数。



# **2.**一维数组的初始化问题

在C语言中，一维字符数组的部分初始化会导致未初始化的元素采用默认初始化。

当你对一个字符数组进行部分初始化时，只为一部分元素提供了初始值，而没有为其余元素提供初始值。这些未提供初始值的元素将采用默认初始化。

对于字符数组来说，**未初始化的元素将被赋予字符数组的默认值，即ASCII码为0的空字符('\0')。**这个空字符表示字符串的结束符，所以未初始化的元素被视为空字符。注意，**这仅适用于静态和全局字符数组。对于局部字符数组（自动变量）来说，默认值是不确定的，它们的值可能是任意的。**

**下面是一些示例来说明部分初始化的情况：**

```c
char arr[5] = {'a', 'b', 'c'}; // 部分初始化，剩余的两个元素会被默认初始化为 '\0'

char arr2[5] = {0}; // 全部初始化为 0，即'\0'，其中包括未提供初始值的元素

char arr3[5]; // 未初始化，所有元素的值是不确定的，这些元素的值可能是任意的
```

总结起来，对于字符数组的部分初始化，未初始化的元素会被默认初始化为空字符('\0')。



# **3.**宏定义的使用

1.对于宏的使用 先替换，再按优先级计算

例：`define num 2+3`

​	`int c=num*num=2+3*2+3=11;`



2.宏定义是**在编译器预处理阶段中就进行替换**了，替换成什么只与define和undefine的**位置有关系**，与它们**在哪个函数中无关**。 （忽视代码逻辑）

```c
#include <stdio.h>
#define a 10 

void foo(); 
int main()
{ 
    printf("%d..", a); 
	foo(); 
	printf("%d", a); 
} 
void foo()
{ 
    #undef a 
    #define a 50 
}
```



  以本题为例：#define a 10 到 #undef a之间的代码在预处理阶段就将a全部换为10，#define a 50后面的代码会将a替换为50。

  使用了#undefine后如果没有#define a 50后面再使用a，编译器就会报错了



# **4.**各个进制的英文

​	十进制：dec

​	十六进制：hex

​	八进制：oct

1. 十进制格式符：
   - 在C语言中，使用 "%d" 或 "%i" 来表示十进制整数。
2. 八进制格式符：
   - 在C语言中，使用 "%o" 表示八进制整数。
3. 十六进制格式符：
   - 在C语言中，使用 "%x" 表示小写字母表示的十六进制整数。
   - 在C语言中，使用 "%X" 表示大写字母表示的十六进制整数



# **5.**对于一个数组a[],sizeof(a+1)输出结果为？

​	在 C 语言中，`sizeof` 运算符的操作数在编译时会被视作指针。因此，`sizeof(a+1)` 实际上是对 `a+1` 表达式求值后的指针的大小。由于指针的大小在不同的机器上可能不同，因此结果也会有所差异。

​	然而，无论数组 `a` 中元素的类型和大小如何，`sizeof` 运算符总是返回指针的大小。因此，`sizeof(a+1)` 的结果在大多数平台上通常是指针的大小，例如在 64 位体系结构上通常为 8 字节。

​	需要注意的是，`sizeof` 运算符计算的是类型的大小，而不是数组的实际长度。要获取数组的元素个数，可以使用 `sizeof(a) / sizeof(a[0])` 的方式来计算。这里假设数组 `a` 的元素都是相同类型的。



# **6.**sizeof()函数

## 1. 根据C99规范， sizeof是一个编译时刻就起效果的运算符，在其内的任何运算都没有意义，

 sizeof(i++); 在编译的时候被翻译成 sizeof((i++的数据类型)) 也就是 sizeof(int); 不会执行i++了。

 sizeof是运算符,它在编译时起作用，而不是运行时。

 也就是说，在编译时，就得到了sizeof(int)，运行时，i++根本没有执行过。（错题分析）



## 2.sizeof一个空的结构体在C++中返回1。

根据C++的规范，每个对象都必须在内存中占据至少一个字节的空间。即使结构体中没有任何成员变量，编译器也会为其分配一个字节的空间，以确保每个对象在内存中都有独一无二的地址。

这样设计有一些原因，其中之一是为了确保每个对象的地址都是唯一的，这对于在内存中寻址和操作对象非常重要。因此，即使结构体是空的，它仍然会占据一个字节的内存空间。



# **7.要使用指针指向二维数组的第二行，可以通过对指针进行适当的偏移来实现。下面是一个示例代码：**

```c
int a[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int (*ptr)[3] = a + 1;
```

在上述代码中，我们首先定义了一个 3x3 的二维数组 `a` 并进行初始化。然后，我们定义了一个指向二维数组第二行的指针 `ptr`。

注意到 `(*ptr)[3]` 中的括号是必需的，它们确保了指针指向的是一个整个的一维数组，而不是指向一个单独的整数。同时，我们使用了数组名 `a` 进行偏移操作 `a + 1`。这个偏移相当于将指针 `ptr` 指向了二维数组的第二行。

现在，指针 `ptr` 将指向二维数组的第二行。

需要注意的是，通过指针访问二维数组的元素时，**可以通过行索引（第一维的索引）和列索引（第二维的索引）进行访问，例如 `ptr[0][2]` 可以访问到第二行第三列的元素。**



# 8. 数组a和&a

a 和 &a 是同一个地址，`printf("%d", a)`,`printf("%d", &a)`结果是相同的。

  但是其代表的含义不同，**`(a+1)`代表从a数组首地址跳跃一个int的长度，`（&a+1）`表示从a数组首地址跳跃一个数组的长度，也就是指向a数组最后一个元素的下一个位置**。（错题解析）

# **9.**atoi()函数

`atoi` 是一个 C 语言标准库函数（stdlib.h），用于将字符串转换为整数。

它的函数原型如下：

```c
int atoi(const char* str);
```

参数 `str` 是要进行转换的字符串，返回值是转换后的整数值。

`atoi` 函数会从字符串的开头开始解析整数，直到遇到非数字字符为止。它会忽略前导的空格字符，并最终返回解析到的整数值。

以下是 `atoi` 函数的示例用法：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    const char* str = "12345";
    int num = atoi(str);
    
    printf("转换后的整数：%d\n", num);
    
    return 0;
}
```

输出：

```
转换后的整数：12345
```

在例子中，`atoi` 函数接收一个字符串 `"12345"` 并将其转换为整数类型，存储在变量 `num` 中。最后打印出转换后的整数。



# 10.指针数组和数组指针

​		指针数组和数组指针是 C 语言中两个不同的概念。

1. 指针数组（Array of Pointers）：指针数组是一个数组，其中的每个元素都是一个指针。这些指针可以指向不同的数据类型或相同的数据类型。例如，`int* arr[5]` 是一个具有5个元素的指针数组，每个元素都是 `int*` 类型的指针。

   示例代码：
   ```c
   int* arr[5];  // 声明一个指针数组
   int x = 5;
   int y = 10;
   arr[0] = &x;  // 指针数组的第一个元素指向变量 x
   arr[1] = &y;  // 指针数组的第二个元素指向变量 y
   printf("%d\n", *arr[0]);  // 输出第一个元素所指向的值（即 x 的值）
   printf("%d\n", *arr[1]);  // 输出第二个元素所指向的值（即 y 的值）
   ```

2. 数组指针（Pointer to an Array）：数组指针是一个指针，它指向一个数组。这个指针可以用于访问数组中的元素。数组指针可以指向一维或多维数组。

   示例代码：
   ```c
   int arr[3] = {1, 2, 3};
   int (*ptr)[3];  // 声明一个指向 int[3] 类型的数组指针
   ptr = &arr;  // 指针指向数组 arr
   printf("%d\n", (*ptr)[0]);  // 输出数组的第一个元素（即 1）
   printf("%d\n", (*ptr)[1]);  // 输出数组的第二个元素（即 2）
   ```

在使用指针数组和数组指针时，需要注意它们的声明、初始化和使用方式。指针数组是一个数组，而数组指针是一个指针，指向一个数组。

例题：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(int argc,char* argv[]) 
{
    char *str[]={"hello","world","think","thank","you"};
    int a[4]={1,2,3,4};
    int (*p)[4]=&a;
    
    printf("%p %p %s %s %ld %ld\n",str,str+1,*str,*(str+1),sizeof(str[1]),sizeof(str));
    printf("%p %p %d %d %d %d %ld %ld %ld",p,p+1,*a,**p,**(p+1),*(a+1),sizeof(a),sizeof(p),sizeof(p+1));
    return 0;
```

# **11.**指针数组是一个二级指针

​	二维数组的数组名是一个数组指针

​					**（超级重点，指针的难点就是它了）**



# **12.**auto和decltype的区别

`auto`关键字在C++中**用于自动推导变量的类型**。通过使用`auto`，**编译器会根据变量的初始化表达式推断出变量的类型**。这样可以简化代码，减少显式类型声明的繁琐性，并且使代码更具灵活性。例如：

```cpp
auto x = 10;  // 推断为整数类型 int
auto y = 3.14;  // 推断为浮点数类型 double
auto z = "Hello";  // 推断为字符串类型 const char*
```

`decltype`关键字**用于获取表达式的类型，而不实际执行表达式**。它在某些情况下特别有用，例如从函数返回值、推导模板类型、获取成员变量的类型等。`decltype`返回的类型与给定表达式的类型完全一致，包括const、引用、指针等修饰符。例如：

```cpp
int foo();
float bar = 3.14;
decltype(foo()) result;  // 推断为函数foo()的返回类型
decltype(bar) value;  // 推断为变量bar的类型，即float
decltype(bar + 5.0) sum;  // 推断为表达式bar + 5.0的类型，即float
```

通过使用`auto`和`decltype`关键字，我们可以减少重复的类型声明和依赖于特定类型的代码，增加代码的可读性和灵活性。



# **13.**转义字符



字符集为每个字符分配了唯一的编号，每个字符除了用它本身的实体表示外，还可以用转义字符来表示 ：

转义字符以\开始，**如果是\x(注意是小写，C语言是区分大小写的)开头，后面接16进制数，如果以\开头，后面接八进制数。** 

  转移字符表示的数据范围有限，因此**对\x开头的 ，只能是\xxx(后面两位表数据)这种格式的，意思是只能接两位数据,最大值为\x7f** 

  **对\开头的，后面可以接三位数据，即\xxx(后三位均为数)，最大值为\177** 


  **另外，还有其他几个常见的转义字符：** 

 											\t ,\n,\a,\b,\r,\f,\v 



# **14**.**声明枚举变量三种方法**



#### 1、先声明枚举类型后定义枚举类型变量



```c
enum WeekdayType  
{  
    sun,mou,tue,wed,thu,fri,sat  
};  
enum WeekdayType today,yesterday,tomorrow;
```



#### 2、声明枚举类型的同时定义枚举类型变量



```c
enum WeekdayType  
{  
    sun,mou,tue,wed,thu,fri,sat   
}today,yesterday,tomorrow;
```



#### 3、直接定义枚举类型变量



```c
enum  
{  
    sun,mou,tue,wed,thu,fri,sat  
}today,yesterday,tomorrow;
```

 

# **15.**结构体大小计算

结构体大小计算有三个原则:
一，结构体变量的首地址，必须是结构体 **"最宽基本类型成员**" 大小的**整数倍**(0被认为是任何数的整数倍)。
二，结构体每个成员相对于结构体首地址的**偏移量**，都是该成员的**整数倍**。
三，结构体的总大小，为结构体 “**最宽基本类型成员**” (将嵌套结构体里的基本类型也算上，得出的最宽基本类型) 大小的**整数倍**

**例：**

**1.1**

```c
struct s1{
char ch1;
char ch2;
int i;
};
12345
```

这个结构体的大小容易计算，为8。ch1和ch2共同占4字节，i占4字节，共8字节。

**1.2**

```c
struct s1{
char ch1;
int i;
char ch2;
};
12345
```

这个和上面哪个只是结构体成员顺序换了一下，但大小就变成了12。是因为要满足偏移量是成员的整数倍，**ch1偏移量是0，i的偏移量不可能是1，因为1不是i(大小4)的倍数，所以i的偏移量是4，ch2的偏移量就变为了8**，加ch2是9，要满足结构体大小是成员大小整数倍，就是12。



# **16.**函数指针和指针函数

​    函数指针和指针函数是两个不同的概念。

1. **函数指针（Function Pointers）**：

  **例如：void (*fun) (int,int);**
  函数指针是指向函数的指针变量。它可以存储函数的地址，并且可以通过函数指针调用对应的函数。使用函数指针可以实现函数的动态调用和回调机制。

例如，以下是一个函数指针的示例：
```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int (*funcPtr)(int, int);  // 声明一个函数指针
    funcPtr = add;             // 将函数的地址赋值给函数指针

    int result = funcPtr(3, 4);  // 通过函数指针调用函数

    printf("Result: %d\n", result);

    return 0;
}
```
在上述示例中，我们声明了一个函数指针`funcPtr`，它可以指向一个接受两个int型参数并返回int型结果的函数。通过将函数`add`的地址赋值给函数指针，并通过函数指针调用函数，实现了动态调用函数。

2. 指针函数（Pointer to a Function）：

  **例如：int* createArray(int size)；**
  指针函数指的是一个返回指针的函数。它的返回值是一个指针，该指针可以指向不同类型的数据。

例如，以下是一个指针函数的示例：
```c
#include <stdio.h>

int* createArray(int size) {
    int* arr = (int*)malloc(size * sizeof(int));
    return arr;
}

int main() {
    int* ptr;

    ptr = createArray(5);

    // 使用指针操作数组
    for (int i = 0; i < 5; i++) {
        ptr[i] = i;
    }

    // 输出数组的值
    for (int i = 0; i < 5; i++) {
        printf("%d ", ptr[i]);
    }

    free(ptr);

    return 0;
}
```

总结：
**函数指针是指向函数的指针变量，用于动态调用函数**。**指针函数指的是函数返回指针的函数，允许函数返回指向不同类型的数据的指针**。它们是不同的概念，用途和处理方式也不同。



# **17.**函数中传数组，传的是指针（数组退化成指针）



# **18.**strcpy()函数和strncpy()函数的区别

它们的区别主要在于对于目标字符串长度的处理

`strcpy()`函数将源字符串复制到目标字符串中，并在目标字符串的末尾添加一个'\0'，表示字符串的结束。但是如果源字符串长度大于目标字符串长度，`strcpy()`函数**将会发生缓冲区溢出的风险，这可能导致程序崩溃或者出现安全漏洞。**

`strncpy()`函数也是将源字符串复制到目标字符串中，但是允许指定要复制的字符数。如果源字符串的长度大于指定的字符数，则目标字符串将被填充'\0'直到达到指定字符数，否则目标字符串不会以'\0'结束。



# **19.**strcpy和strcat的区别

`strcpy` 和 `strcat` 是 C 语言中用于字符串操作的函数，它们的区别在于以下几个方面：

1. 功能：
   - `strcpy` 函数用于将源字符串复制到目标字符串中，包括源字符串的终止符。
   - `strcat` 函数用于将源字符串追加到目标字符串的末尾，不重复包括终止符。

2. 形式参数：
   - `strcpy` 函数的形式参数如下：
     
     ```c
     char* strcpy(char* destination, const char* source);
     ```
     其中，`destination` 是目标字符串的指针，`source` 是源字符串的指针。
   - `strcat` 函数的形式参数如下：
     ```c
     char* strcat(char* destination, const char* source);
     ```
     其中，`destination` 是目标字符串的指针，`source` 是源字符串的指针。
   
3. 目标字符串的要求：
   - `strcpy` 函数要求目标字符串必须具有足够的空间来容纳整个源字符串，包括源字符串的终止符。否则可能发生缓冲区溢出。
   - `strcat` **函数要求目标字符串必须已经以终止符结尾**，并且具有足够的空间来容纳源字符串的内容以及新的终止符。否则可能发生缓冲区溢出。

4. 返回值：
   - `strcpy` 函数返回指向目标字符串的指针，即 `destination` 的值，在成功复制后与传入的 `destination` 相同。
   - `strcat` 函数返回指向目标字符串的指针，即 `destination` 的值，在成功追加后与传入的 `destination` 相同。

总结： `strcpy` 函数用于字符串的复制，**将源字符串的内容（包括终止符）复制到目标字符串中**。 `strcat` 函数用于字符串的追加，**将源字符串的内容追加到目标字符串的末尾，不重复包括终止符**。两个函数在目标字符串的要求和功能上有所不同。



# **20.**错题分析

以下程序运行时输入：123456789↙（错题）

则程序运行结果是（ ）

```c
#include <stdio.h>
int main()
{	int x, y;
    scanf("%2d%*4s%2d", &x, &y);
 	printf("%d", y - x);
 	return0;
}
```

这段代码是一个简单的C程序，它从用户输入中读取两个整数，并计算两个整数之间的差值，然后将结果打印出来。

代码的执行流程如下：
1. 在主函数 `main` 中，声明了两个整型变量 `x` 和 `y`。
2. 使用 `scanf` 函数从用户输入中读取数据，并使用格式化字符串 `%2d%*4s%2d` 来解析输入。解析过程如下：
   - `%2d`：读取两位整数并将其存储在变量 `x` 中。
   - `%*4s`：**读取四个字符并丢弃它们，不存储在任何变量中**。
   - `%2d`：读取两位整数并将其存储在变量 `y` 中。
3. 计算 `y - x` 的值，并通过 `printf` 函数将结果打印出来。
4. `return 0` 表示程序正常结束，并将返回值设为0。

根据代码和输入格式，以下是一个示例的执行过程：

输入：`12345678`

解析过程：
- `%2d`：将 `12` 存储在变量 `x` 中。
- `%*4s`：读取 `3456`，但不存储在变量中。
- `%2d`：将 `78` 存储在变量 `y` 中。

输出：`66`

注意：此程序假定输入格式是正确的，即前两个数字均为两位数，并且之后的四个字符可以被忽略。如果输入格式不符合要求，可能导致未定义行为或输出错误的结果。



# **21.**大端和小端（以及判断方法）

在计算机中，字节序（Byte Order）指字节在内存中的存储顺序。主要有两种字节序：**大端模式（Big Endian）和小端模式（Little Endian）。**

1. 大端模式（Big Endian）：**在大端模式下，最高有效字节（Most Significant Byte，MSB）存储在最低的内存地址，而最低有效字节（Least Significant Byte，LSB）存储在最高的内存地址。**

示例：对于16位整数值0x1234，其在大端模式下的存储如下：

```
地址   0x1000  0x1001
      +------+------+
值    | 0x12 | 0x34 |
      +------+------+
```

2. 小端模式（Little Endian）：**在小端模式下，最低有效字节（LSB）存储在最低的内存地址，而最高有效字节（MSB）存储在最高的内存地址**。

示例：对于16位整数值0x1234，其在小端模式下的存储如下：

```
地址   0x1000  0x1001
      +------+------+
值    | 0x34 | 0x12 |
      +------+------+
```

字节序在计算机中使用的主要场景是在多字节数据类型（例如整数、浮点数等）的存储和传输中。对于在不同字节序的机器之间进行数据交换，需要进行字节序的转换。

需要注意的是，大多数现代计算机体系结构都采用小端模式，包括x86、ARM等。但是，网络传输协议如TCP/IP通常使用大端模式。因此，在进行数据网络传输时，需要对字节序进行适当的转换。



## **判断方式：（联合体法）**



在C语言中，可以使用联合体（union）来判断处理器的字节序（大小端模式）。下面是一个示例代码：

```c
#include <stdio.h>

int main() 
{
    union
    {
        int value;
        char bytes[sizeof(int)];
    } u;
    
    u.value = 1;
    
    if (u.bytes[0] == 1) 
    {
        printf("小端模式\n");
    } 
    else 
    {
        printf("大端模式\n");
    }
    
    return 0;
}
```

在这个示例中，我们定义了一个联合体`u`，其中包含一个`int`型的变量`value`和一个大小为`sizeof(int)`的字符数组`bytes`。我们将整数`1`赋值给`value`，然后通过检查`bytes`数组的第一个元素来判断字节序。

如果处理器是小端模式（Little Endian），则数组的第一个字节存储的是最低有效字节；如果是大端模式（Big Endian），则数组的第一个字节存储的是最高有效字节。因此，如果`u.bytes[0]`等于`1`，则处理器是小端模式；否则，是大端模式。

请注意，联合体的用法涉及到底层内存表示，因此在不同的编译器和平台上结果可能会有所不同。**此代码示例假定整数类型`int`在处理器上以4字节存储，并且字符类型`char`占用1字节。如果你在使用不同类型或不同平台时遇到问题，可能需要进行适当的修改。**



# 22.有符与无符运算，结果为无符



# **23.**浮点类型数据的组成

C语言中的浮点类型数据主要包括以下几个部分：

1. **符号位**（Sign bit）：用于表示浮点数的正负号。0表示正数，1表示负数。

2. **指数部分**（Exponent）：表示浮点数的指数，用于调整浮点数的大小。指数部分由多个二进制位组成。

3. **尾数部分**（Mantissa/Fraction）：也称为尾数或小数部分，用于表示浮点数的精度和小数部分。尾数部分由多个二进制位组成。

在C语言中，浮点类型数据主要有两种类型：float和double。float通常为单精度浮点数，占用4个字节，可以表示大约6-7位十进制数。double通常为双精度浮点数，占用8个字节，可以表示大约15位十进制数。

**对于单精度浮点数，它包含1个符号位、8个指数位和23个尾数位。而双精度浮点数包含1个符号位、11个指数位和52个尾数位。**

这些部分共同组成了浮点类型数据，使得浮点数能够表示更大范围的值和更高精度的小数。



# **24.部分输入函数的特性**（可补充）

​		(1).`scanf("%[^\n]",str);` 是一个用于从标准输入读取字符串的 `scanf` 函数格式化字符串。它可以读取一行输入，**直到遇到换行符** `\n` 为止，并将读取的内容存储到字符串 `str` 中，直到换行符为止。

在这个格式化字符串中，`%[^\n]` 是一个转换说明符，**它告诉 `scanf` 读取除了换行符以外的所有字符。`[^\n]` 表示除了换行符以外的字符都可以被接受。**

这种用法可以用于读取整行输入，包括空格和特殊字符，直到遇到换行符为止。



​		(2).`fgets()` 函数有以下一些特点：

​		格式：

​					`char *fgets(char *str, int n, FILE *stream);`

1. 读取整行：`fgets()` **函数会从输入流中读取一行字符，包括换行符**。它会一直读取，直到换行符或达到指定的字符数（`n-1`）。

2. 字符数限制：`fgets()` 函数根据指定的字符数 `n` 来限制读取的字符数，防止缓冲区溢出。它将读取的字符保存在目标字符数组中，保证不会超过指定的字符数。

3. 自动添加空字符：`fgets()` **会在读取的字符后自动添加一个空字符 `\0`，构成一个以空字符结尾的字符串，以表示字符串的结束。**

4. **包含换行符**：`fgets()` **会将读取到的换行符（`\n`）也包含在字符串中**。这样可以保留用户输入中的换行符信息。

5. 返回值：`fgets()` 函数会返回一个指向目标字符串的指针，如果读取成功，则返回目标字符串的地址。如果读取失败或到达文件末尾，返回一个空指针。

6. 安全性：相较于一些其他读取字符串的函数（比如 `gets()`），`fgets()` 函数更加安全，它可以避免缓冲区溢出的风险。

由于 `fgets()` 具有上述特性，它通常被用于读取整行输入，包括用户输入和文件读取，特别是在需要确保输入安全性和处理换行符的情况下。



# 25.浮点型数据之间判断相等性

浮点型数据在内存中存储时，有可能保存的是近似值（除了小数点后面的数是2的幂次方）

**笔试题**：

怎么判断一个浮点型数据是否等于0？

**（用精度比浮点型数据更大的数去比较）**

即：

```c
float a;

if(-0.000001<a&&a<0.000001);
```



# 26.仿写strstr()函数（判断是否子集）

当编写`strstr()`函数的仿写时，我们需要在给定的字符串中查找一个子字符串。以下是一个示例代码，实现了类似`strstr()`函数的功能：

```c
#include <stdio.h>

char* my_strstr(const char* haystack, const char* needle) {
    if(*needle == '\0') {
        return (char*) haystack; // 如果子字符串为空，则返回原始字符串
    }

    const char* p1 = haystack;
    while(*p1) {
        const char* p1_start = p1;
        const char* p2 = needle;

        while(*p1 && *p2 && *p1 == *p2) {
            p1++;
            p2++;
        }

        if(*p2 == '\0') {
            return (char*) p1_start; // 如果找到了子字符串，返回匹配的起始位置
        }

        p1 = p1_start + 1;
    }

    return NULL; // 如果在原始字符串中没有找到子字符串，返回NULL
}

int main() {
    const char* haystack = "Hello, World!";
    const char* needle = "World";

    char* result = my_strstr(haystack, needle);

    if(result) {
        printf("Found needle at index %ld\n", result - haystack);
    } else {
        printf("Needle not found\n");
    }

    return 0;
}
```

上述代码中的`my_strstr()`函数接收两个参数：`haystack`（原始字符串）和`needle`（要查找的子字符串）。函数会从原始字符串中查找子字符串，并返回子字符串第一次出现的位置。如果没有找到子字符串，则返回`NULL`。

在`main()`函数中，我们使用`my_strstr()`函数在字符串`"Hello, World!"`中查找子字符串`"World"`。如果找到了子字符串，将打印出其第一次出现的位置（索引）；否则，打印出提示信息"Needle not found"。

请注意，这只是一个简单的示例实现，可能并不像标准库函数`strstr()`那样高效和健壮。在实际应用中，建议使用标准库函数或更成熟的实现。
